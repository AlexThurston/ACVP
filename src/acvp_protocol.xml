<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-ietf-acvp-protocol-0.4" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

    <title abbrev="Abbreviated Title">Automated Cryptographic Validation Protocol </title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Barry Fussell" initials="B.F." role="editor" surname="Fussell">
      <organization>Cisco Systems</organization>

      <address>
        <postal>
          <street>170 West Tasman Dr.</street>

          <!-- Reorder these if your country does things differently -->

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>bfussell@cisco.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2018"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>template</keyword>

    <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

    <abstract>
      <t>This document defines the Automated Cryptographic Validation Protocol(ACVP).</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>ACVP enables communication between a cryptographic module that is embedded inside of a
        device or otherwise running on a platform accessible via computer network, and an external
        testing system, using standard network communication interfaces and protocols. This
        communication protocol can also be used to validate the correctness of the implementations
        of the algorithms in the cryptographic module with a validation authority. This document
        describes how ACVP is structured with respect to the client-server model, the messaging
        protocol, optional features and flows.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

    <section anchor="caps_reg" title="Overview">
      <t>ACVP has the following goals:</t>
      <t>
        <list style="symbols">
          <t> To work in situations where the testing system is remote from the cryptographic
            module, e.g. running as a process on a separate device.</t>
          <t> To enable automated testing that can take place with a minimum of human
            interaction.</t>
          <t> To enable the testing system to discover the capabilities of the module being tested;
            that is, the particular algorithms and parameters that the module supports.</t>
          <t> To provide extensibility that can be used to introduce tests for new algorithms, and
            new tests for existing algorithms.</t>
          <t> To be compatible with emerging automated validation systems wherever possible,
            especially the FIPS-140 Cryptographic Algorithm Validation Program.</t>
          <t> To provide a standard communication method so that vendors can utilize the same
            testing service for FIPS-140, 3rd party crypto verification and product FCS readiness
            testing.</t>
        </list>
      </t>

      <t>ACVP defines how to communicate a request (to execute a cryptographic operation) to a
        cryptographic module, and how to communicate the corresponding response (containing the
        output of that operation) back to a testing system. It defines a transport (based on HTTP or
        HTTPS), an encoding and message format (which is negotiated), and a set of message
        exchanges. Each vector test set corresponds to a single message exchange driven from the
        client associated with the module under test. ACVP does not define the cryptographic
        algorithms, nor does it detail the precise conditions for a response to be acceptable.
        Instead, it references existing specifications for those algorithms, and defines a mapping
        between the data on the wire and the algorithm testing specification. ACVP does not define
        detailed conformance criteria, such as those in FIPS-140. Instead, it aims to be independent
        of particular conformance criteria, so that it can be used in multiple domains with
        different (even potentially conflicting) conformance criteria. ACVP does not define an
        interface that can be used to manage or control a cryptographic module.</t>
      <section title="Audience">
        <t>This document is written to address multiple audiences:</t>
        <t>
          <list style="symbols">
            <t> Crypto module developers who require validation testing</t>
            <t> Crypto validation organizations who will perform validation testing</t>
            <t> Crypto module customers that desire validation testing results or verifiable
              artifacts of testing</t>
          </list>
        </t>
      </section>

      <section title="Goals">
        <t>The goals for this document are to provide a messaging protocol that can be used with
          existing authentication and communication protocols to provide a way to test crypto
          modules. The following functions are outside the scope of this document:</t>
        <t>
          <list style="symbols">
            <t> The API to the cryptographic module</t>
            <t> How the tests are generated</t>
            <t> How the results/artifacts are stored or managed</t>
            <t> Authentication used</t>
            <t> Scalability</t>
            <t> Management interface</t>
          </list>
        </t>
        <t>With that in mind there are several expectations when building a server used as a
          validation authority. A validation authority shall use HTTPS, TLS 1.2 or greater and
          mutual authentication. Therefore a client that expects to be used with a validation
          authority shall have the same requirements. A server, proxy or client developed for the
          purposes of internal organizational testing only may chose not to include some of those
          features.</t>
      </section>

      <section title="Terminology">
        <t> TBD </t>
      </section>
    </section>


    <section title="Architecture">
      <figure align="center" anchor="xml_figure1">
        <preamble>Server/Client Architecture</preamble>

        <artwork align="left"><![CDATA[

                           +----------------------------------------+
                           |                    +-----------------+ |
+----------+               | Entropy ---------->| DRBG----Encrypt | |
| ACV      |               |                    |         Auth    | |
| Server   |<=============>| +--------+         |                 | |
+----------+               | | ACV    |<------->| PKI-----Key Est | |
                           | | Client |    ^    |         Sign    | |
                           | +--------+    |    |                 | |
                           |            Crypto  | Crypto Module   | |
                           |            Module  +-----------------+ |
                           |              API                       |
                           |                                        |
                           |        Device Under Test (DUT)         |
                           +----------------------------------------+


           ]]></artwork>

      </figure>

      <section title="Server/Client Architecture">
        <t>A server client model is used where the roles are defined as:</t>
        <t>
          <list style="symbols">
            <t> ACV Client - resides in, or accessible from, the device under test and communicates
              with the ACV server using Java Script Object Notation (JSON) as well as the crypto
              module using product specific methods.</t>
            <t> ACV Server - Sends JSON formatted messaging and test data to the ACV client and
              processes test responses.</t>
            <t> ACV Proxy - Resides between the ACV server and ACV client to proxy the connection
              for the client. This is particularly useful when the client does not support TLS, key
              management or have signature capabilities and they are required by the server. An
              example architecture is provided in Figure 2.</t>
            <t> Device Under Test - contains the ACV client and the crypto module under test which
              can include various algorithms and functions that encrypt/decrypt, generate keys,
              signatures, perform varifications and DRBG functions.</t>
            <t> Crpyographic Module API - This is the interface to the crypto module from the ACV
              Client. This interface is environment specific and will vary depending on the API
              available on the crypto module.</t>
          </list>
        </t>
      </section>

      <section title="Server/Proxy Architecture">
        <figure align="center" anchor="xml_figure2">
          <preamble>Server/Proxy Architecture</preamble>

          <artwork align="left"><![CDATA[


                +-----------------------------------------------------+                           
                |                         +-------------------------+ |
+----------+    |     +----------+        |                         | |
| ACV      |    |     | ACV      |        |                         | |
| Server   |<========>| Proxy    |<======>| +--------+   +--------+ | |
+----------+    |     +----------+        | | ACV    |<->| Crypto | | |
                |                         | | Client |   | Module | | |
                |                         | +--------+   +--------+ | |
                |                         |                         | |
                |                         |      DUT                | |
                |                         +-------------------------+ |
                | Vendor/Customer Premise                             |
                +-----------------------------------------------------+

           ]]></artwork>

        </figure>
      </section>
    </section>
    <section title="ACV Protocol">
      <t>The ACV protocol will utilize existing mechanisms for transport coordinated with JSON
        formatted messaging.</t>
      <figure align="center" anchor="xml_figure3">
        <preamble>Protocol Layering</preamble>
        <artwork align="left"><![CDATA[
+-----------------------------------------------+
| JSON Formatted ACVP request/response messages |
+-----------------------------------------------+
| HTTP[S] message transfer and signaling        |
+-----------------------------------------------+
| TLS for transport security(recommended)       |
+-----------------------------------------------+
| TCP for transport                             |
|_______________________________________________|

           ]]>
        </artwork>
      </figure>
      <section title="HTTP URI Hierarchy">
        <figure align="center" anchor="xml_figure4">
          <artwork align="left"><![CDATA[

          +-------------+------------------+-------------------------+
             server          path prefix          resource
          +-------------+------------------+-------------------------+
  https://acvts.nist.gov/validation/acvp/v1/testSession/1/vectorSet/1
          +-------------+----------+----+--+-------------------------+
                           context  API   |
                                       version

           ]]>
          </artwork>

        </figure>
        <t>Note that deployments utilizing ACV Proxy server may use a different protocol, e.g.,
          HTTP, custom server, context and port number to interact with the DUT.</t>
      </section>

      <section title="HTTP URI Resources">
        <t>In the table below, any part of a resource path enclosed in brackets are replaced by an
          instance of what is described in the brackets. For example &lt;testSessionId&gt; could be
          replaced with 1.</t>
        <texttable anchor="uri_table" title="Resources and their available operations">
          <preamble>
            <spanx style="emph">An empty cell for a resource and HTTP Method combination denotes
              that the server returns an HTTP Status 405 code "Method not allowed (405)".</spanx>
          </preamble>
          <ttcol align="left" width="20%">Resource</ttcol>
          <ttcol align="left" width="17%">GET (read)</ttcol>
          <ttcol align="left" width="17%">POST (create)</ttcol>
          <ttcol align="left" width="17%">PUT (update)</ttcol>
          <ttcol align="left" width="17%">DELETE</ttcol>

          <c>/vendors</c>
          <c><xref target="vendors_get">Returns a list of vendors</xref></c>
          <c><xref target="vendors_post">Register a new vendor</xref></c>
          <c/>
          <c/>

          <c>/vendors/&lt;vendorId&gt;</c>
          <c><xref target="vendor_get">Retrieve Information for a specific vendor</xref></c>
          <c/>
          <c><xref target="vendor_put">Update a vendor</xref></c>
          <c><xref target="vendor_delete">Delete a vendor</xref></c>

          <c>/testSessions</c>
          <c><xref target="testSessions_get">Returns a list of Test Sessions for the current user</xref> (Optional)</c>
          <c><xref target="testSessions_post">Create a new Test Session</xref></c>
          <c/>
          <c/>

          <c>/testSessions/&lt;testSessionId&gt;</c>
          <c><xref target="testSession_get">Returns information about the specific Test Session</xref> (Optional)</c>
          <c/>
          <c><xref target="testSession_put">Submit the Test Session for validation.</xref></c>
          <c><xref target="testSession_delete">Cancel testing for a specific Test Session</xref></c>

          <c>/testSessions/&lt;testSessionId&gt;/results</c>
          <c><xref target="testSession_results_get">Request Validation Results for a Test Session</xref></c>
          <c/>
          <c/>
          <c/>
          
          <c>/testSessions/&lt;testSessionId&gt;/vectorSets</c>
          <c><xref target="vectorSets_get">Returns a list of Vector Sets for the specific Test Session</xref></c>
          <c/>
          <c/>
          <c/>

          <c>/testSessions/&lt;testSessionId&gt;/vectorSets/&lt;vectorSetId&gt;</c>
          <c><xref target="vectorSet_get">Vector Set download request</xref></c>
          <c/>
          <c/>
          <c><xref target="vectorSet_delete">Cancel testing for a specific Vector Set</xref></c>

          <c>/testSessions/&lt;testSessionId&gt;/vectorSets/&lt;vectorSetId&gt;/results</c>
          <c><xref target="vectorSet_results_get">Request Validation Results for a Vector Set</xref></c>
          <c><xref target="vectorSet_results_post">Initial Submission of Vector Set Test Results</xref><cref>POST and PUT seem redundant</cref></c>
          <c><xref target="vectorSet_results_put">Update Vector Set Test Results Submission</xref></c>
          <c/>

          <c>/testSessions/&lt;testSessionId&gt;/vectorSets/&lt;vectorSetId&gt;/expected</c>
          <c><xref target="vectorSet_expected_get">Expected Test Results</xref> (Optional)</c>
          <c/>
          <c/>
          <c/>
        </texttable>

        <t> The resource path is appended to the path prefix to form the URI used with an HTTP
          Method to perform the desired ACVP operation. For example to create a new test session
          using the "/testSessions" resource is "/acvp/v1/testSessions" (assuming an empty
          context). To create a new Test Session, the ACVP client would use the following HTTP
          request-line: </t>
        <t>POST /acvp/v1/testSessions HTTP/1.1</t>

        <t>Likewise, to request a specific vector set from the server the ACVP client would use the
          following request-line:</t>

        <t>GET /acvp/v1/testSessions/1/vectorSets/1 HTTP/1.1</t>
      </section>
    </section>

    <section title="Security">
      <t>It is recommended that HTTPS and TLS 1.2 or greater be used in order to enforce a secure
        communication method. Not all environments will have TLS so HTTP with some level of
        authentication may be the only option.</t>
    </section>

    <section title="Authentication">
      <t>It is recommended that an authentication scheme be used. Depending on the target
        environment and usage objectives, that can be as weak as basic HTTP authentication or as
        strong as TLS mutual certificate authentication. Definition of an authentication scheme will
        not be discussed here, but should be agreed upon between the client and server owning
        entities including the servers owned by the validation authorities. For the purposes of the
        message flow examples, no authentication will be used.</t>
    </section>

    <section title="Traceability">
      <t> TBD </t>
    </section>

    <section title="Encoding">
      <t>The encoding used for the request/response messaging will be JSON. The data will be
        identified by: Content-type: application/json In order to allow environment specific
        extensions to a particular version of the ACV protocol, a top-level JSON keyword, extensions
        will be used to extend the OE description and/or the capabilities. Extensions may be ignored
        by the ACV server. Vector and vector response data will be JSON encoded.</t>
    </section>

    <section title="Versioning">
      <t>The version of the ACVP protocol will be carried with each message and will contain a
        simple major.minor format. Major version changes will not be backward compatible, however
        additions and enhancements that do not disrupt compatibility will be indicated with a minor
        version change. A server may accept a down-level version from the client if it can process
        at a lower level. If not, it will reject the session. All subsequent messages will carry the
        negotiated version value.</t>
    </section>

    <section title="Messaging">

      <section title="Product Registration/Capabilities Exchange">
        <t>The product registration message will include many of the normal cryptographic algorithm
          identification line items that are found when filling out a testing form. This pre-test
          message will carry the Company name, primary contact (OE information) as well as a
          detailed list of the supported cryptographic algorithms to be tested during a session. The
          server will return the vector test list to the client. It will consist of a list of vector
          set IDs (vsId) each of which represent a set of test vectors which can be used to request
          the test vectors at a later time.</t>

      </section>

      <section title="Test Exchange">
        <t>The test exchange consists of the ACV client requesting a particular set of vectors
          selected from the vector test list. The server responds with the test vectors. Once the
          client has run the vectors the response data will be returned to the server for
          processing. The client will repeat this process until all of the tests in the session test
          list have been processed. The client may request results from the server at any time,
          however if test sets have not been completed the overall status will be incomplete.</t>
      </section>
    </section>

    <section title="Message Formats">
      <t>Servers may require a contextual path in the URI prior to the service section and
        clients/proxies must be able to support it.</t>

      <t>Unique variable definitions to identify the vector set, device and session include:</t>
      <t>
        <list style="symbols">
          <t> Session - represented by a JSON Web Token(JWT). Within the JWT, the JWT ID(JTI) will
            be a unique identifier that will be generated by the server and can be used as a session
            ID.</t>
          <t> Vector Set - represented by the VS-ID which represents a specific CAVS vector request
            file, e.g. gcmEncryptIntIV128.req. Passed to the client as part of the capabilities
            exchange.</t>
        </list>
      </t>
      <t>JWT example:</t>
      <figure align="center" anchor="xml_json1">
        <artwork align="left"><![CDATA[
{
"alg" : "none"
}
   {
      "iss" : "nist.gov",
      "exp" : 1426420800,
      "company" : "MyCompany",
      "jti" : 0987654321,
      "pkey" : "cc74f56acdba635079383a03941d68db55c7b3c2fcd0f9716c9b62d56d3f8f546e9ec0244203b6ab4a82c08a46b1dbc243c6434861e31ab51065f41dbce00482498d4474d1ed3b09dc727af6b9c788fdb5da283c5a98cf8ac9e473f34644c6bbfc146e28f8158f725ce25bcb73e0a2c05378739d101df15a0c1297a1a2e3abc7912e24caba5465e78f694ad0d3cf48f2f01c4580d774d592684756efbdf0cc7648470dd78a3b38973b18946e71c8feaf2f28b93a2ff36b1cc31236e5845145899e8a0438aeb1073bc0d23d5c7898845d5227867a38234739595d55a44e41a39feff8eb447757fc6b246d92f02fe43b46e46c7403a5966f40ba4e01ca64e955c5"
   }
   {
   Empty octet string (since alg is none).
   }
           ]]></artwork>
      </figure>

      <t>The JWT can be secured if desired using the header encryption "alg" value defined to
        HS256(HMAC-SHA256) or one of the other secure values. Key agreement would follow RFC7518. </t>

      <t> The first four claims are required, however "pkey" is an optional private claim used to
        pass the key used for encrypting the database at the server. Enabling this option is
        discussed further in <xref target="reg_capex"/></t>

      <section title="Establish Connection HTTPS GET/200 OK">
        <t>Establish the connection, send POST and receive 200 OK response with JWT from server.</t>

        <figure align="center" anchor="xml_json2">
          <artwork align="left"><![CDATA[
POST /validation/acvp/register HTTP1.0
Host: www.acvts.nist.gov/acvp
Capabilities information(see next section)

..authentication happens here..

HTTP 1.0 200 OK
Status: 200 OK
Content-Type: application/json
Content-Length: (length of JWT)
{
"accessToken" : 
"eyJhbGciOiJIUzI1NiIsI.eyJpc3MiOiJodHRwczotcGxlL.mFrs3Zo8eaSNcxiNfvRh9dqKP4F1cB",
}

Once the session is established the client must include the JWT with 
each message.

           ]]></artwork>
        </figure>

        <t>The authentication mechanism will be defined by the server.</t>



      </section>

      <section anchor="vendors" title="Vendor Resources">
        <t>The available properties for vendor resources are:
          <list>
            <t><spanx style="strong">url</spanx> - <spanx style="verb">string</spanx>, identifier for this resource</t>
            <t><spanx style="strong">name</spanx> - <spanx style="verb">string</spanx></t>
            <t><spanx style="strong">website</spanx> - <spanx style="verb">string</spanx></t>
            <t><spanx style="strong">emails</spanx> - array of <spanx style="verb">string</spanx>s</t>
            <t><spanx style="strong">contacts</spanx> - an array of contact objects,
              <list>
                <t><spanx style="strong">name</spanx> - <spanx style="verb">string</spanx></t>
                <t><spanx style="strong">emails</spanx> - array of <spanx style="verb">string</spanx>s</t>
                <t><spanx style="strong">phoneNumbers</spanx> - array of phone objects,
                  <list>
                    <t><spanx style="strong">number</spanx> - <spanx style="verb">string</spanx></t>
                    <t><spanx style="strong">type</spanx> - <spanx style="verb">string</spanx>, one of (fax, voice)</t>
                  </list>
                </t>
              </list>
            </t>
            <t><spanx style="strong">address</spanx> - an address object,
              <list>
                <t><spanx style="strong">street</spanx> - <spanx style="verb">string</spanx></t>
                <t><spanx style="strong">locality</spanx> - <spanx style="verb">string</spanx></t>
                <t><spanx style="strong">region</spanx> - <spanx style="verb">string</spanx></t>
                <t><spanx style="strong">country</spanx> - <spanx style="verb">string</spanx></t>
                <t><spanx style="strong">postalCode</spanx> - <spanx style="verb">string</spanx></t>
              </list>
            </t>
          </list>
        </t>
        <section anchor="vendors_get" title="Vendor Listing">
          <t><spanx style="strong">GET /vendors</spanx></t>
          <t>Returns a listing of vendors.</t>
          <section title="Parameters">
            <t>
              <list>
                <t><xref target="paging">Paging Parameters</xref></t>
              </list>
            </t>
          </section>
          <section title="Response">
            <figure align="center">
              <artwork align="left"><![CDATA[
[
    {"acvVersion": "0.5"},
    {"vendors": [
        {
            "url": "/acvp/v1/vendors/1",
            "name": "Cisco",
            "website": "www.cisco.com",
            "contacts": [{
                "name": "John Doe",
                "email": "johndoe@cisco.com"
            }]
        },
        {
            "url": "/acvp/v1/vendors/2",
            "name": "Acme, LLC",
            "website": "www.acme.acme",
            "emails" : [ "inquiry@acme.acme" ],
            "contacts": [{
                "name": "Jane Smith",
                "emails": ["jane.smith@acme.acme"],
                "phoneNumbers" : [
                    {
                        "name": "555-555-0001",
                        "type" : "fax"
                    }, {
                        "name": "555-555-0002",
                        "type" : "voice"
                    }
                ],
                "address" : {
                    "street" : "123 Main Street",
                    "locality" : "Any Town",
                    "region" : "AnyState",
                    "country" : "USA",
                    "postalCode" : "123456"
                }
            }]
        }
    ]}
]
           ]]></artwork>
            </figure>
          </section>
        </section>
        <section anchor="vendors_post" title="Create a New Vendor">
          <t><spanx style="strong">POST /vendors</spanx></t>
          <t>Request the creation of a new Vendor.</t>
          <section title="Request">
            <figure align="center">
              <artwork align="left"><![CDATA[
[
    {"acvVersion": "0.5"},
    {
      "name": "Acme, LLC",
      "website": "www.acme.acme",
      "emails" : [ "inquiry@acme.acme" ],
      "contacts": [{
          "name": "Jane Smith",
          "emails": ["jane.smith@acme.acme"],
          "phoneNumbers" : [
              {
                  "name": "555-555-0001",
                  "type" : "fax"
              }, {
                  "name": "555-555-0002",
                  "type" : "voice"
              }
          ],
          "address" : {
              "street" : "123 Main Street",
              "locality" : "Any Town",
              "region" : "AnyState",
              "country" : "USA",
              "postalCode" : "123456"
          }
      }]
    }
]
           ]]></artwork>
            </figure>            
          </section>
          <section title="Response">
            <figure align="center">
              <artwork align="left"><![CDATA[
[
    {"acvVersion": "0.5"},
    {"url": "/acvp/v1/vendors/2"}
]
         ]]></artwork>
          </figure>
        </section>
      </section>
        <section anchor="vendor_get" title="Vendor Information">
        </section>
        <section anchor="vendor_put" title="Update an existing Vendor">
        </section>
        <section anchor="vendor_delete" title="Remove a Vendor">
        </section>
      </section>

      <section anchor="testSessions" title="Test Sessions">
        <section anchor="testSessions_get" title="Test Session Listing (Current User)">
          <t>Returns a list of vendors</t>
        </section>
        <section anchor="testSessions_post" title="Create a New Test Session">
        </section>
        <section anchor="testSession_get" title="Test Session Information">
          <t>Returns a list of vendors</t>
        </section>
        <section anchor="testSession_put" title="Submit For Validation">
        </section>
        <section anchor="testSession_delete" title="Cancel Test Session">
        </section>
        <section anchor="testSession_results_get" title="Request Validation Results">
        </section>
      </section>
      
      <section anchor="vectorSet" title="Vector Sets">
        <section anchor="vectorSets_get" title="Vectors Set Listing">
          <t>Returns a list of vendors</t>
        </section>
        <section anchor="vectorSet_get" title="Vector Set Download">
          <t>Returns a list of vendors</t>
        </section>
        <section anchor="vectorSet_delete" title="Cancel Testing of a Vector Set">
          <t>May be cases where a particular vector set may not be cancelled and the entire Test Session will need to be cancelled instead.</t>
        </section>
        <section anchor="vectorSet_results_get" title="Request Validation Results">
          <t>Returns a list of vendors</t>
        </section>
        <section anchor="vectorSet_results_post" title="Submit Results">
        </section>
        <section anchor="vectorSet_results_put" title="Update Results Submission">
        </section>
        <section anchor="vectorSet_expected_get" title="Retrieve Expected Results">
        </section>
 
      </section>
      
      <section anchor="reg_capex" title="Product Registration with Capabilities">
        <t>POST the registration to the server consisting of the ACVP version, Operating Environment
          (OE), vector encoding, capabilities and any extensions. In addition there are a few
          parameters that specify session specific information:</t>

        <t>
          <list style="symbols">

            <t>certificateRequest - If an algorithm certificate is not desired for this registration
              populate the field "certificateRequest" with "no", otherwise "yes".</t>
            <t>debugRequest - If this vector session is for the purposes of testing the client or
              DUT prior to a certificate request and desires the answers to the vectors as well,
              indicate with "yes", otherwise omit the keyword or indicate with "no"</t>
            <t>production - If this is a production environment indicate so with "yes", otherwise
              omit this keyword or indicate with "no". A production environment may not be able to
              support intermediate value tests and therefore those tests will be excluded.</t>
            <t>encryptAtRest - The client may request the server to encrypt all data at rest by
              registering "encryptAtRest" with "yes". Omitting the "encryptAtRest" field or
              registering with "no" will indicate to the server that no encryption is require for
              the data at rest.</t>
          </list>
        </t>

        <t>Note that when a certificate request is made, production and debugRequest shall be
          omitted or set to "no". Conversely if no certificate is requested, the
          operationalEnvironment section may be omitted.</t>



        <figure align="center" anchor="xml_json3">
          <artwork align="left"><![CDATA[
POST /validation/acvp/register HTTP1.0
User Agent:
Host: www.acvts.nist.gov/acvp
Accept: 
[
 { "acvVersion": "0.4" },
 { "operation" : "register",
   "certificateRequest" : "yes",
   "debugRequest" : "no",
   "production" : "no",
   "encryptAtRest" : "yes",
   "oeInformation" : {
     "vendor": {
        "name" : "Cisco",
        "website": "www.cisco.com",
        "contact": [{
            "name" : "John Doe",
            "email" : "johndoe@cisco.com"
        }]
    },
    "module": {
      "name": "Cisco ACV Test Module",
      "version": "1.0",
      "type": "Software"
    },
    "operationalEnvironment" : {
        "dependencies" : [{
            "type" : "software",
            "name" : "Linux 3.1",
            "cpe"  : "cpe-2.3:o:ubuntu:linux:3.1"
        },{
            "type" : "processor",
            "manufacturer" : "Intel",
            "family" : "ARK",
            "name" : "Xeon",
            "series" : "5100",
            "features" : [ "rdrand" ]
        }]
    },
    "implementationDescription" : "Sample crypto module for demonstrating ACV protocol."
  },
  "capabilityExchange" : {
  "algorithms" : [
         {
  "algorithm" : "AES-GCM",
  "prereqVals" : [{"algorithm" : "AES", "valValue" : "123456"},
                {"algorithm" : "DRBG", "valValue" : "123456"}],
  "direction": [
    "encrypt",
    "decrypt"
  ],
  "ivGen" : "internal",
  "ivGenMode" : "8.2.1",
  "keyLen" : [
            128,
            256
             ],
  "tagLen" : [
            96
               ],
  "ivLen" : [
             96
               ],
  "dataLength" : [
             0,
             128,
             136
               ],
  "aadLen" : [
             128,
             136
               ]
         }
      ]
    }
  }
]
           ]]></artwork>
        </figure>

        <t>Successful response from server is 200 OK and a set of vector set identifiers. The
          extensions section is optional and can be implementation specific for value add. Follow on
          versions could include protocol information.</t>

        <figure align="center" anchor="xml_json4">
          <artwork align="left"><![CDATA[
200 OK Response:
[
  { "acvVersion": "0.4" },
  { "capabilityResponse" : { "vectorSets" : [
                       {"vsId":1437},
                       {"vsId":1438}] } , 
    "testSession" :       {"testId":458} , 
    "accessToken" : "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiAibmlzdC5vcmciLCJleHAiOiAxNDYyOTg0OTUzLCJjb21wYW55IjogIkNpc2NvIiwianRpIjo0NTh9.zDhd3WrLcb1Xf5-VKOX6k-G70mACbi1tdir8qHAMPyQ" 
  }
]
           ]]></artwork>
        </figure>


      </section>

      <section anchor="vector_dl" title="Vector Set Download Request">
        <t> After registration, the server provides a list of vector sets to the client, each
          identified by a VS-ID. The client shall download, process, and upload test results for
          each vector set, one at a time. Note that the client shall upload complete test results
          for each processed vector set, i.e. containing a result for every test case in the vector
          set. </t>
        <figure align="center" anchor="xml_json5">
          <artwork align="left"><![CDATA[
GET /validation/acvp/vectors?vsId=1437  HTTP1.0
Host: www.acvts.nist.gov/acvp
Authorization: Bearer JWT
            ]]></artwork>
        </figure>

        <t>The server will respond with the vector set associated with the vsId for the client to
          process. The actual test group content contained in the response will vary depending on
          the specific sub-specification of the algorithm and testType being tested.</t>




        <figure align="center" anchor="xml_json6">
          <artwork align="left"><![CDATA[

200 OK Response:
Status: 200 OK
Content-Type: application/json
Content-Length: <length of results>
[
 { "acvVersion": "0.4" },
 { "vsId": 1437,
   "algorithm": "AES-GCM",
   "testGroups": [
    {
      "direction": "encrypt",
      "keyLen": 128,
      "ivLen": 96,
      "ptLen": 0,
      "aadLen": 128,
      "tagLen": 128,
      "testType" : "AFT"
      "tests": [
        {
          "tcId": 12340,
          "key": "30BA1DBCB530347A148FB286D9A59757",
          "pt": "",
          "aad": "6CA553A59DFBD8F7E0DA619470F8986C"
        },
        {
          "tcId": 12341,
          "key": "AB7BB9349285B3E7403E99FED8B5060E",
          "pt": "",
          "aad": "79504FF995F70FFD328D7070CCBD62F1"
        }.....
]

	<With debugRequest set iv, ct and tag would be included>

            ]]></artwork>
        </figure>


        <t> If the server did not have enough time to generate the vector set for a given test
          session, the server may reply: </t>
        <figure align="center" anchor="xml_json7">
          <artwork align="left"><![CDATA[
HTTP 1.0 200 OK
Status: 200 OK
Content-Type: application/json
Content-Length: <length of results>
[
  { "acvVersion": "0.4" },
  { "vsId": 1437,
    "retry" : 10
  }
]
           ]]></artwork>
        </figure>
        <t> Where the retry value represents the number of seconds for the client to wait before
          retrying the request. The server may set the retry value based on the current server load
          and expected processing time to generate the vector set. </t>
      </section>

      <section anchor="vector_dl2" title="Submit Test Results">
        <t>The client will send this request to submit the test results for an individual vector
          set. Similar to the vector set download the format will vary depending on the specific
          sub-specification of the algorithm and testType being tested.</t>

        <figure align="center" anchor="xml_json8">
          <artwork align="left"><![CDATA[
POST /validation/acvp/vectors?vsId=1437 HTTP1.0
Host: www.acvts.nist.gov/acvp
Authorization: Bearer JWT
Accept:   
[
 { "acvVersion": "0.4" },
 { "vsId": 1437,
   "testResults": [
   {
   "tcId": 12340,
   "iv": "01020304C077A707E56C22AC",
   "ct": "",
   "tag": "53B15E85E377F8B5B6BFC2DE915FD622"
   },
   {
   "tcId": 12341,
   "iv": "01020304D666587803BCBAD7",
   "ct": "",
   "tag": "E7B1F2D77D82C6EB3C9CEFF16C376D9C"
   }, ...
]
           ]]></artwork>
        </figure>
      </section>

      <section anchor="results_req" title="Validation Results Request">
        <t>The client will send this request to learn the validation results for an individual
          vector set.</t>

        <figure align="center" anchor="xml_json9">
          <artwork align="left"><![CDATA[
GET /validation/acvp/results?vsId=1437 HTTP1.0
User Agent:
Host: www.acvts.nist.gov/acvp
Accept: /


Response to GET is:

HTTP 1.0 200 OK
Status: 200 OK
Content-Type: application/json
Content-Length: <length of results>
[
  { "acvVersion": "0.4" },
  { "results" : {
      "vsId" : 1437,
      "disposition" : "incomplete",
      "tests" : [
            { "tcId" : 12340, "result" : "passed", "reason" : ""},
            { "tcId" : 12341, "result" : "incomplete", "reason" : ""},
            { "tcId" : 12342, "result" : "failed", "reason" : "Authentication tag mismatch"}
              ]
   }
]
           ]]></artwork>
        </figure>

        <t>The results request is an optional flow since some clients may not require success/fail
          information. Another possibility is to provide an out of band management session on the
          server may provide access to algorithm test results.</t>

        <t>"disposition" is defined overall for the entire vector set as:</t>
        <t>
          <list style="symbols">
            <t>"fail" indicates at least one test case has failed.</t>
            <t>"unreceived" indicates the server has not received responses from the client for all
              the test cases.</t>
            <t>"incomplete" indicates not all tests have been processed by the server, however none
              have failed thus far.</t>
            <t>"expired" indicates not all the test case responses were received from the client
              prior to expiry.</t>
            <t>"passed" indicates all test cases have been processed by the server and have
              passed.</t>

          </list>
        </t>
        <t>"result" is defined for individual test cases:</t>
        <t>
          <list style="symbols">
            <t>"fail" indicates the test case has failed.</t>
            <t>"unreceived" indicates the server has not received a response from the client for the
              test case.</t>
            <t>"incomplete" indicates the server has not processed the test case.</t>
            <t>"expired" indicates the client did not send the test case response to the server
              prior to expiry.</t>
            <t>"passed" indicates the test case passed.</t>
            <t>"reason" provides additional detail for the test result.</t>
          </list>
        </t>
      </section>

      <section anchor="optional_flows" title="Optional Flows">
        <t>The cancel URI can be used by the client to free a session. The server is responsible for
          maintaining any database information for traceability or debugging purposes it desires.
          This may be important for those cases where there are test failures.</t>
        <figure align="center" anchor="xml_json10">
          <artwork align="left"><![CDATA[
POST /validation/acvp/cancel HTTP1.0
Host: www.acvts.nist.gov/acvp
Authorization: Bearer JWT
           ]]></artwork>
        </figure>
        <t>The server response will always be 200 OK.</t>
      </section>
    </section>



    <!-- This PI places the pagebreak correctly (before the section title) in the text output. -->

    <?rfc needLines="8" ?>

    <section title="Vector Set Expiration">
      <t> Vector sets can expire. For example, in terms of a validation authority use, the vector
        sets are one-time use only. Old vector sets can never be reused to obtain a new validation
        certificate for an algorithm implementation or to update an existing certificate. Expiration
        is a server specific definition which depends on database costs, need for artifacts, etc. If
        the vector set has expired, the server will reply with an expired response when the client
        attempts to download the vector set: </t>
      <figure align="center" anchor="xml_json11">
        <artwork align="left"><![CDATA[
HTTP 1.0 200 OK
Status: 200 OK
Content-Type: application/json
Content-Length: <length of results>
[
  { "acvVersion": "0.4" },
  { "vsId" : <vs-id>,
    "status" : "expired"
  }
]
           ]]></artwork>
      </figure>

      <t>The ACVP protocol requires server implementations to generate test values and retain the
        data while the ACVP client processes and returns the results. Some crypto modules
        implementing the client-side ACVP protocol may not return results immediately. The ACVP
        protocol design implies the server must retain the test values to verify the client test
        responses at some time in the future. However, some test vector sets are fairly large, which
        could place significant storage requirements on ACVP server implementations. To alleviate
        long term storage requirements, ACVP allows for an expiration timestamp to be set when a
        test vector set is generated by the server. </t>
      <t>The vector set expiration timestamp must be included by the server in the vector set when
        the client downloads the vector set. The server may change the expiration timestamp of a
        previously issued vector set to extend its lifetime subject to server policy. The expiration
        timestamp must be in the 'expiry' JSON value, which is included in the JSON encoded vector
        set. The expiry JSON value will be a string value of the UTC timestamp using form
        "YYYY-MM-DD HH:MM:SS". The following figure shows a partial JSON encoded vector set that
        contains the expiry value. </t>

      <figure align="center" anchor="xml_json12">
        <artwork><![CDATA[
              [
                { "acvVersion": "0.4" },
                { "vsId": 1437,
		  "expiry": "2018-12-31 23:59:59",
                  "algorithm": "AES-GCM",
                  "testGroups": [
                    {
                      "direction": "encrypt",
                      "keyLen": 128,
                      "ivLen": 96,
                      "ptLen": 0,
                      "aadLen": 128,
                      "tagLen": 128,
                      "tests": [
                        {
                          "tcId": 12340,
                          "key": "1529BAC6229586F057FAA59353851686",
                          "pt": "",
                          "aad": "4B11160620475D8EE440C3795CF62D26"
                        },
			.
			.
			.
			<remainder of vector set omitted from figure>
			.
			.
			.
          ]

	    ]]></artwork>
      </figure>
      <section title="Resending Test Responses">
        <t> When one or more test cases fails, the client will need to correct the issue in the
          crypto module and send the responses again. The resending of responses for failed test
          cases will occur for an entire vector set. Therefore, even if only a single test case in
          the vector set failed, the client will need to download, process, and upload responses to
          the server for the entire vector set (presumably after the problem has been corrected in
          the DUT). The resending of vector set responses must occur prior to expiry. </t>
      </section>
    </section>
    
    <section title="Paging Parameters" anchor="paging">
      <t>Some<cref>should we instead add a property to indicate that paging was enabled to allow implementations to decide?</cref> resources require paging in order to avoid returning large amounts of data. To faciliate
        paging the following Query parameters should be allowed on resources where paging is
        necessary.
        <list>
          <t><spanx style="verb">limit</spanx> - the number of entries to return</t>
          <t><spanx style="verb">offset</spanx> - the offset into the list of entries</t>
        </list>
      </t>
      <t>The response will indicate the offset and the total count using <spanx style="verb">offset</spanx> and
        <spanx style="verb">total</spanx> properties.</t>
    </section>
    

    <section title="Error Codes">
      <t>Errors will follow HTTP[S] numbering scheme. In addition errors as well as 200 messages may
        carry JSON encoded information that describes in detail the error and any associated
        troubleshooting information. A non-exhaustive list of JSON encoded error messages are in
        Appendix B.</t>
    </section>


    <section title="Custom Specification Objects">
      <section title="BitString">
        <t> Bitstrings are used to communicate a string of bits between the ACVP server and IUT. </t>
        <section title="Endianness">
          <t> BitStrings should be considered in big endian order, unless otherwise specified by the
            algorithm. </t>
          <t> The hex string "FA" (assuming all bits are considered) should represent the bits
            11111010 (in MSb) or the value 250. </t>
        </section>
        <section title="Hex to Bitstring Parsing">
          <t> "valueLen" will be used as the example, but it can apply to any bit length
            registration/vector set/etc parameters. </t>
          <t> When a "value" is provided along with a "valueLen", the "valueLen" MUST be considered
            when parsing the hex string represented in "value", EXCEPT in empty bitstring cases,
            which MUST be represented as an empty string "". Parsing Hex strings into Bit strings is
            especially important for algorithms such as the SHA variations that may only include a
            portion of bits from the provided hex string. When only a portion of bits from a Hex
            string are considered, bits for use in the bitstring should be taken from the most
            significant bits, meaning the lesser significant bits are the bits that are dropped. </t>
          <section title="Hex string parsing examples">
            <t>
              <list style="symbols">
                <t> valueLen: 8, value: "FA", should be parsed as the bits 11111010, or the value
                  250. </t>
                <t> valueLen: 7, value: "FA", should be parsed as the bits 1111101, or the value
                  125. </t>
                <t> valueLen: 5, value: "FA", should be parsed as the bits 11111, or the value 31. </t>
                <t> valueLen: 3, value: "FA", should be parsed as the bits 111, or the value 7. </t>
                <t> valueLen: 0, value: "", MUST be interpreted as an empty bit string. </t>
              </list>
            </t>
          </section>
        </section>
      </section>
      <section title="Range">
        <t> The Range object can be used to convey a range of values. It contains its own set of
          properties made up of "min", "max", and "increment". </t>
        <section title="Range JSON examples">
          <t> A range object specifying a minimum of 0, a maximum of 8, with an increment of 1. This
            range object includes the values 1, 2, 3, 4, 5, 6, 7, and 8. </t>
          <figure align="center" anchor="xml_json13">
            <artwork>
              <![CDATA[
          {
            "myRange" : 
            {  
              "min" : 1,
              "max" : 8,
              "increment" : 1
            }
          }
          ]]>
            </artwork>
          </figure>
          <t> A range object specifying a minimum of 0, a maximum of 8, with an increment of 2. This
            range object includes the values 0, 2, 4, 6, and 8. </t>
          <figure align="center" anchor="xml_json14">
            <artwork>
              <![CDATA[
          {
            "myRange" : 
            {  
              "min" : 0,
              "max" : 8,
              "increment" : 2
            }
          }
          ]]>
            </artwork>
          </figure>
        </section>
      </section>
      <section title="Domain">
        <t> The Domain object can be used to specify a set of values similar to Range, albeit with
          more control. A domain can be made up of an array of objects, where those objects can be
          literal values, and/or Range objects. </t>
        <section title="Domain JSON examples">
          <t> Several sample domain objects that state 0, 8, 16, 32, 96, 128, 192, and 256 are valid
            values. </t>
          <figure align="center" anchor="xml_json15">
            <artwork>
              <![CDATA[
          {
            "myDomain" : 
            [
              {  
                "min" : 0,
                "max" : 16,
                "increment" : 8
              },
              32,
              96,
              {  
                "min" : 128,
                "max" : 256,
                "increment" : 64
              }
            ]
          }
          ]]>
            </artwork>
          </figure>

          <figure align="center" anchor="xml_json16">
            <artwork>
              <![CDATA[
          {
            "myDomain" : 
            [
              0, 8, 16, 32, 96, 128, 192, 256
            ]
          }
          ]]>
            </artwork>
          </figure>
        </section>
        <section title="Additional Domain Information">
          <t> Because the Domain is an array of objects consisting of (potentially) both literals
            and ranges, algorithms that use an array of integers can be used interchangably with the
            Domain object. </t>
        </section>
      </section>
    </section>

    <section title="Other Considerations">
      <t>When an ACVP client is attached to a cryptographic module that is in use, access to ACVP
        MUST be controlled so that only an administrator or other authorized user can send and
        receive ACVP messages. This is because an attacker that has access to ACVP can potentially
        use it to probe for weaknesses in the cryptographic module.</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>Original ACVP created by David McGrew, Bill Hudson and Anthony Grieco of Cisco Systems.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119; </references>

    <section anchor="app-reg-ex" title="JSON Formatting Guidelines">
      <t>All JSON keywords shall use lower camelCase format with no underscores or hyphens and use
        the following characters only a-z, A-Z, 0-9. Keywords shall abbreviate common words and
        phrases wherever possible for brevity.</t>

      <t>For example: password length - pwLen plain text length - ptLen </t>

      <t>Keywords should be chosen such that they are informative and brief, for example: </t>

      <t> [ { "acvVersion": "0.4" }, { "results" : { "disposition" : "incomplete", } } ] </t>
      <t>Metadata assigned to the keyword may use any format which best reflects the information
        being represented including hyphens, underscores alternating case, numbers, etc. However,
        brevity should be a major consideration, for example:</t>
      <t> "algorithms" : [ { "algorithm" : "AES-GCM", "mode" : "modes", "ivGen" : "internal",
        "ivGenMode" : "8.2.1", } All metadata representing strings or big numbers shall use double
        quotes at both ends. Big numbers require conversion from strings to whatever format is used
        by the DUT. Numerical values of integer size or with decimal points may use quotations if
        those values are generally used as a string, for example the acvVersion would generally be
        used in displaying information not in any mathematical operations. Something like keyLen or
        ptLen values would be better used without quotes to avoid having to convert the string to an
        integer for use in the code. </t>

    </section>

    <section anchor="app-reg-ex2" title="JSON Encoded Error Messages">
      <t> TBD </t>

    </section>

    <!-- Change Log

v00 2006-03-15  EBD   Initial version

v01 2006-04-03  EBD   Moved PI location back to position 1 -
                     v3.1 of XMLmind is better with them at this location.
v02 2007-03-07  AH    removed extraneous nested_list attribute,
                     other minor corrections
v03 2007-03-09  EBD   Added comments on null IANA sections and fixed heading capitalization.
                     Modified comments around figure to reflect non-implementation of
                     figure indent control.  Put in reference using anchor="DOMINATION".
                     Fixed up the date specification comments to reflect current truth.
v04 2007-03-09 AH     Major changes: shortened discussion of PIs,
                     added discussion of rfc include.
v05 2007-03-10 EBD    Added preamble to C program example to tell about ABNF and alternative 
                     images. Removed meta-characters from comments (causes problems).

v06 2010-04-01 TT     Changed ipr attribute values to latest ones. Changed date to
                     year only, to be consistent with the comments. Updated the 
                     IANA guidelines reference from the I-D to the finished RFC.  -->
  </back>
</rfc>
